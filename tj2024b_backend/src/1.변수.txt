[변수]
	- 변하는 수 
	- 값을 넣을 수 있는 빈 그릇과 같습니다.
	1. 변수 형태 
		자료형 변수명 = 리터럴;
	2. 변수 선언 
		1. 선언 : 자료형 변수명;
		2. 초기화 : 자료형 변수명 = 리터럴;
	3. 변수명 주의할점
		1. 숫자로 시작 불가능하다.
		2. 특수문자 _ 와 $ 사용 하고 띄어쓰기 불가능하다
		3. 키워드(예약어) : if for int 등등 불가능하다.
		* 카멜표기법 : 소문자로 시작하고 두번째 단어는 첫글자를 대문자 한다.
		numberofStudent -> numberOfStudent
	4. 변수의 값 호출
		변수명
	5. 변수의 값 수정
		변수명 = 새로운 값
		
[리터럴]
	- 데이터 그 자체, 카보드로부터 입력한 자료
	- 자바 리터럴 : 논리 boolean, 문자 char, 정수 int, 실수 double
	
[자료형]

	1. 목적 : 타입의 저장범위를 고려하여 저장할 데이터를 적절하게 선택하여 사용하므로 효율성을 높일 수 있다.
	  - 자바 기본 타입 , 8가지. (+String 클래스타입)
	  [논리]
	  		boolean		1바이트	true 혹은 false
	  
	  
	  [문자]
	  		char		2바이트	유니코도, 작은따옴표로 감싼 문자		'A'
	  	객체 (X)String	n바이트	문자열클래스, 큰따옴표로 감싼 문자열	"ABC"
	  
	  
	  [정수]
	  		byte		1바이트		-128 ~ +127 저장 
	  		short		2바이트		+-3만정도 저장
	  		int			4바이트		+-21억정도 저장 	리터럴정수(키보드로 입력한 정수), 정수 중에 기본 타입(모두 int)
	  		long		8바이트		+-21억이상 정도	리터럴 뒤에 L을 붙이면 저장 가능(리터럴은 int이므로 long에 대입 불가)
	  
	  
	  [실수, 부동 소수점]
	  		float		4바이트		소수점 8자리 표현. 실수리터럴 뒤에 F붙이기
			double		8바이트		소수점 17자리 표현. 실수리터럴 실수 중에 기본 타입
	
		** 왜 타입을 여러가지로 구분해서 범위에 맞게 사용해야 하는가?
			메모리를 효율적으로 적적하게 선택하여 사용하기 위함
			박스는 큰데 들어있는 데이터가 적으면 공간 낭비
			
[부동 소수점]
	0과 1사이의 실수는 끝없는 무한대 표현 가능하므로, 컴퓨터는 한계를 만들었다.
	- 지수부 : 숫자의 크기를 조정하는 역할 ex) 몇 승
	- 가수부 : 숫자의 유효 자릿수를 표현 ex) 숫자 자체
	float : 부호1비트, 지수부 8비트, 가수부 23비트
	double : 부호1비트, 지수부 11비트, 가수부 52비트
		ex) - 6.25
			1. 2진수로 표현 					: -110.01 
			2. 부호 : 0(양수) 1(음수)			: 1
		1000000
			가수 : 1, 지수 : 6 (10을 6번 곱해야함) 1.0*10^6
	- 실제 연산이 중요한 부분, 업무에서는 실수타입 사용하는데 한계(오차)가 있다.
		해결법 : 라이브러리 BigDecimal 또는 문자열 처리
		
[ 소수 자릿수를 이동하는 방법 ]
	100.0 * 10 : 1000.0
	100.0 / 10 : 10.0
	
[ 상수 ]
	- 초기화 이후 변하지 않는 값
	- final키워드
	- 상수명은 관례적으로 대문자를 사용한다.	

[ 리터럴 ]
	- 개발자가 키보드로부터 입력한 숫자, 문자, 논리 ... 를 일컫는 말
	- 자바는 이러한 리터럴값들을 상수풀(메모리공간)이라는 곳에서 *상수*로 저장 한다.

[ 타입변환 ]
	1. 자동 타입 변환 , 묵시적 형 변환 
		- 메모리 크기가 작은 것 부터 큰 순으로 변환
		- 데이터의 손실이 없다.
		- 연산(계산) 중에 큰 값으로 변환된다.( 메모리 손실 방지 )
		- byte -> short , char -> int -> long -> float -> double 
		(+) 연산중에 묵시적 형변환  / 연산시 피연산자중에 더 큰 타입으로 결과를 반환한다.
			byte + byte => int	 (예외) byte와 short 연산 결과는 무조건 int로 반환된다.
			byte + short => int 	 
			int + int => int 
			int + long => long 
			int + float => float 
			float + double => double 
			
	2. 강제 타입 변환 , 명시적 형 변환 , 캐스팅 
		- 1. 메모리 크기가 큰것 부터 작은 순으로 변환 
		- 2. 데이터의 (허용범위 외)손실이 있을수도 있다.
		- 3. (변환할타입명)변수명 , (변환할타입명)리터럴값
		- double -> float -> long -> int -> short , char -> byte
 
 
 [변수 유형에 따른 용도]
 	지역변수 : 특정한 { } 안에서 선언한 변수
 		- 선언위치 : 함수 내부에서 선언
 		- 사용범위 : 선언된 특정한 {} 내부에서만 사용 가능
 		- 사용메모리 : 스택 메모리
 		- 생성소멸 : 함수가 실행될 때 생성, 생성되고 함수가 종료될 때 소멸
 	
 	매개변수 : 함수 호출시 함수에게 전달하는 값을 대입받는 변수
 		- 선언위치 : 함수 선언시 함수명(타입 매개변수, 타입 매개변수){ }
 		- 범위/메모리/생성소멸 : (지역변수와 동일)
 	
 	멤버변수 : 클래스 { } 이고 함수 { } 밖에서 선언된 변수, 주로 객체의 속성/특성을 다룬다
 		- 선언위치 : 객체 멤버변수로 선언
 		- 사용범위 : private 이면 현재 클래스에서만 사용, 아니면 다른 클래스에서 사용 가능
 		- 메모리 : 힙 메모리
 		- 생성소멸 : 인스턴스가 생성될 때 힙에 생성, GC가 메모리를 수거할 때 소멸
 											* GC(가비지콜렉터)쓰레기 수거 기준 : 인스턴스를 참조당하지 않는 인스턴스
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
	
	
	 

